# -*- coding: utf-8 -*-
"""sprint04.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11XF14fQksA3fUr7txmPmUYEsQSyNCtm4

#DATASET 1: ENDEREÇOS ATIBAIA

Importar Bibliotecas
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
# %matplotlib inline
import seaborn as sns
import geopandas as gpd

"""Carregar os Dados"""

#tratamento dos dados da tabela

dados_atibaia = pd.read_csv('3504107_ATIBAIA.csv', sep = ';', decimal = ',', encoding = 'latin1')

dados_atibaia

"""Tratar os dados para análises"""

# eliminar as colunas vazias

dados_atibaia = dados_atibaia.dropna(axis=1, how='all')

dados_atibaia

# Alterar o nome das colunas para facilitar a análise

dados_atibaia = dados_atibaia.rename(columns = {'NOM_TIPO_SEGLOGR':'NOME_TIPO', 'NOM_TITULO_SEGLOGR':'NOME_TITULO', 'NOM_SEGLOGR': 'NOME_LOGRADOURO', 'NOM_COMP_ELEM1':'NOME_COMPLEMENTO','DSC_LOCALIDADE' : 'NOME_BAIRRO'})

dados_atibaia

# selecionar as colunas com as informações relevantes para nossas análises

dados_atibaia_final = dados_atibaia[['COD_UF', 'COD_MUNICIPIO', 'NOME_TIPO', 'NOME_LOGRADOURO','NUM_ENDERECO', 'NOME_COMPLEMENTO', 'LATITUDE', 'LONGITUDE', 'ALTITUDE', 'NOME_BAIRRO', 'CEP']]

dados_atibaia_final

# uma das análises válidas é descobrir a MODA do CEP e NOME_BAIRRO, NOME_LOGRADOURO e NOME_TIPO, desta forma, descobriremos quais os Bairros, CEP, Logradouro e Tipo que mais se repetem
# para os produtores registrados


moda_cep = dados_atibaia_final['CEP'].mode()[0]
moda_bairro = dados_atibaia_final['NOME_BAIRRO'].mode()[0]
moda_logradouro = dados_atibaia_final['NOME_LOGRADOURO'].mode()[0]
moda_tipo = dados_atibaia_final['NOME_TIPO'].mode()[0]

moda_cep

moda_bairro

moda_logradouro

moda_tipo

# Outra análise útil é encontrar mínimo, máximo e média da altitude das propriedades dos produtores cadastrados, pois, são informações úteis para determinar o que será cultivado em determinado local
# uma vez que determinados tipos de produtos não crescem em qualquer altitude

dados_atibaia_final_altitude = dados_atibaia_final.loc[dados_atibaia_final['ALTITUDE'] != 'NaN']

dados_atibaia_final_altitude

dados_atibaia_final_altitude['ALTITUDE'] = dados_atibaia_final_altitude['ALTITUDE'].astype(float)

dados_atibaia_final_altitude.groupby('COD_MUNICIPIO') \
              .agg(altitude_max = pd.NamedAgg('ALTITUDE','max'),
                   altitude_min = pd.NamedAgg('ALTITUDE','min'),
                   altitude_media = pd.NamedAgg('ALTITUDE','mean')) \
              .reset_index()

from google.colab import files
dados_agrotoxico_final.to_csv('dados_atibaia_final.csv')
files.download('dados_atibaia_final.csv')

# RESUMO DATAFRAME 1
# Em resumo este dataframe é uma tabela de endereços, onde, podemos tirar insights referentes a localização dos produtores e suas propriedades para assim, as agências de crédito rural poderem
# conhecer melhor a estrutura dos solicitantes do crédito.

"""#DATAFRAMES 2 - PRONAMP E PRONAF"""

# PRONAF é o Programa Nacional de Fortalecimento da Agricultura Familiar com ojetivo de fortalecer os pequenos produtores rurais do Brasil
# PRONAMP é p Programa Nacional de Apoio ao Médio Produtor Rural

#Leitura e tratamento das tabelas, separadas por programa para cobrir cada um mais minuciosamente

dados_bcb_pronaf = pd.read_csv('PRONAF.csv', sep = ';', decimal = ',', thousands='.', encoding = 'utf-8-sig')
dados_bcb_pronamp = pd.read_csv('Pronamp.csv', sep = ';', decimal = ',', thousands='.', encoding = 'utf-8-sig')

dados_bcb_pronamp.head()

dados_bcb_pronamp.rename(columns={'uf': 'UF', 'adesao_area Amparada_ha': 'adesao_areaAmparada_ha'}, inplace=True)

dados_bcb_pronamp.head()

#Lista separada por regiões
centro_oeste = ["DF", "GO", "MT", "MS"]
nordeste = ["AL", "BA", "CE", "MA", "PB", "PE", "PI", "RN", "SE"]
norte = ["AC", "AP", "AM", "PA", "RO", "RR", "TO"]
sudeste = ["SP","MG","RJ","ES"]
sul = ["RS", "SC", "PR"]
nacional = ["DF", "GO", "MT", "MS","AL", "BA", "CE", "MA", "PB", "PE", "PI", "RN", "SE","AC", "AP", "AM", "PA", "RO", "RR", "TO", "SP","MG","RJ","ES", "RS", "SC", "PR"]

dados_centro_oeste_pronamp = dados_bcb_pronamp[dados_bcb_pronamp['UF'].isin(centro_oeste)]
dados_nordeste_pronamp = dados_bcb_pronamp[dados_bcb_pronamp['UF'].isin(nordeste)]
dados_norte_pronamp = dados_bcb_pronamp[dados_bcb_pronamp['UF'].isin(norte)]
dados_sudeste_pronamp = dados_bcb_pronamp[dados_bcb_pronamp['UF'].isin(sudeste)]
dados_sul_pronamp = dados_bcb_pronamp[dados_bcb_pronamp['UF'].isin(sul)]
dados_nacional_pronamp = dados_bcb_pronamp[dados_bcb_pronamp['UF'].isin(nacional)]

dados_bcb_pronaf

dados_centro_oeste_pronaf = dados_bcb_pronaf[dados_bcb_pronaf['UF'].isin(centro_oeste)]
dados_nordeste_pronaf = dados_bcb_pronaf[dados_bcb_pronaf['UF'].isin(nordeste)]
dados_norte_pronaf = dados_bcb_pronaf[dados_bcb_pronaf['UF'].isin(norte)]
dados_sudeste_pronaf = dados_bcb_pronaf[dados_bcb_pronaf['UF'].isin(sudeste)]
dados_sul_pronaf = dados_bcb_pronaf[dados_bcb_pronaf['UF'].isin(sul)]
dados_nacional = dados_bcb_pronaf[dados_bcb_pronaf['UF'].isin(nacional)]

"""- Funções Aplicáveis

- Amostra regional
"""

#Esse valor representa a quantidade de contratos ofertados pelo PRONAMP na região sul do país
soma_contratos_sul = dados_sul_pronamp['adesao_qtdContratos'].sum().round()
soma_contratos_sul

#Esse valor representa a média de de contratos ofertados pelo PRONAMP na região sul do país
media_contratos_sul = dados_sul_pronamp['adesao_qtdContratos'].mean().round()
media_contratos_sul

#Esse valor representa a mediana do valor amparado pelo PRONAMP na região sul do país
mediana_vlrAmparado_sul = dados_sul_pronamp['adesao_vlrAmparado'].median().round()
mediana_vlrAmparado_sul

# Vale destacar que calculamos somente a amostra regional do sul uma vez que para calcular das demais regiões basta trocar as variáveis, o método continua o mesmo

"""- Amostra Nacional"""

#Esse valor representa a quantidade de contratos fornecidos no país inteiro pelo PRONAMP
soma_qtdContratos_nacional = dados_nacional_pronamp['adesao_qtdContratos'].sum().round()
soma_qtdContratos_nacional

#Esse valor representa a soma da área amparada pelo PRONAMP no país inteiro
soma_areaAmparada_nacional = dados_nacional_pronamp['adesao_areaAmparada_ha'].sum().round()
soma_areaAmparada_nacional

#Esse valor representa a média de contratos por estado
media_contratos_nacional = dados_nacional_pronamp['adesao_qtdContratos'].mean().round()
media_contratos_nacional

#Esse valor representa a média de área amparada por estado pelo PRONAMP no país inteiro
media_areaAmparada_nacional = dados_nacional_pronamp['adesao_areaAmparada_ha'].mean().round()
media_areaAmparada_nacional

#Esse valor representa a soma do valor amparado por estado pelo PRONAMP no país inteiro
soma_vlrAmparado_nacional = dados_nacional_pronamp['adesao_vlrAmparado'].sum().round()
soma_vlrAmparado_nacional

#Esse valor representa a média do valor amparado por estado pelo PRONAMP tendo em vista a quantidade ofertada no país inteiro
media_vlrAmparado_nacional = dados_nacional_pronamp['adesao_vlrAmparado'].mean().round()
media_vlrAmparado_nacional

"""## Inferências PRONAF e PRONAMP"""

# Alterar o nome das colunas para facilitar a análise

dados_bcb_pronaf = dados_bcb_pronaf.rename(columns = {'UF':'SIGLA_UF', 'Adesão_Área Amparada (ha)':'ADESAO_AREA_AMPARADA_HA', 'Adesão_Qtd. Contratos': 'ADESAO_QTDE_CONTRATOS',
                                                   'Adesão_Vlr. Amparado':'ADESAO_VALOR_AMPARADO_R$','Adesão_Vlr. Adicional' : 'ADESAO_VALOR_ADICIONAL_R$',
                                                   'comm_perdas_Área Amparada (ha)':'COMUNICACAO_PERDA_AMPARADA_HA','comm_perdas_Qtd. Contratos':'COMUNICACAO_PERDA_QTD_CONTRATOS',
                                                  'comm_perdas_Vlr. Amparado':'COMUNICACAO_PERDA_VALOR_AMPARADO_R$','cobert_def_Área Amparada (ha)':'COBERTURA_DEF_AREA_HA','cobert_def_Qtd. Contratos':'COBERTURA_DEF_QTD_CONTRATOS',
                                                   'cobert_def_Vlr. Amparado':'COBERTURA_DEF_VALOR_AMPARADO_R$','cobert_def_Vlr. Deferido':'COBERTURA_VALOR_DEFERIDO_R$','cobert_anal_Área Amparada (ha)':'COBERTURA_ANALISE_AREA_AMPARADA_HA',
                                                   'cobert_anal_Qtd. Contratos':'COBERTURA_ANALISE_QTD_CONTRATOS','cobert_anal_Vlr. Amparado':'COBERTURA_ANALISE_VALOR_AMPARADO_R$'})

dados_bcb_pronaf.head()

# Alterar o nome das colunas para facilitar a análise

dados_bcb_pronamp = dados_bcb_pronaf.rename(columns = {'UF':'SIGLA_UF', 'Adesão_Área Amparada (ha)':'ADESAO_AREA_AMPARADA_HA', 'Adesão_Qtd. Contratos': 'ADESAO_QTDE_CONTRATOS',
                                                   'Adesão_Vlr. Amparado':'ADESAO_VALOR_AMPARADO_R$','Adesão_Vlr. Adicional' : 'ADESAO_VALOR_ADICIONAL_R$',
                                                   'comm_perdas_Área Amparada (ha)':'COMUNICACAO_PERDA_AMPARADA_HA','comm_perdas_Qtd. Contratos':'COMUNICACAO_PERDA_QTD_CONTRATOS',
                                                  'comm_perdas_Vlr. Amparado':'COMUNICACAO_PERDA_VALOR_AMPARADO_R$','cobert_def_Área Amparada (ha)':'COBERTURA_DEF_AREA_HA','cobert_def_Qtd. Contratos':'COBERTURA_DEF_QTD_CONTRATOS',
                                                   'cobert_def_Vlr. Amparado':'COBERTURA_DEF_VALOR_AMPARADO_R$','cobert_def_Vlr. Deferido':'COBERTURA_VALOR_DEFERIDO_R$','cobert_anal_Área Amparada (ha)':'COBERTURA_ANALISE_AREA_AMPARADA_HA',
                                                   'cobert_anal_Qtd. Contratos':'COBERTURA_ANALISE_QTD_CONTRATOS','cobert_anal_Vlr. Amparado':'COBERTURA_ANALISE_VALOR_AMPARADO_R$'})

dados_bcb_pronamp.head()

# Gráficos para comparação entre os valores distribuidos por Unidades Federativas

# Utilizamos a tabela do PRONAF porém a mesma metodologia pode ser aplicada para o PRONAMP

plt.bar(dados_bcb_pronaf['SIGLA_UF'], dados_bcb_pronaf['ADESAO_AREA_AMPARADA_HA'], align='edge')
plt.xlabel('Unidades Federativas', fontsize=12)
plt.ylabel('Área Amparada (ha)', fontsize=12)
plt.title('Área Amparada do Pronaf por UF', fontsize=14)
plt.figure(figsize=(20, 10))
plt.tight_layout()

# Criação do gráfico de pizza usando Matplotlib

# Utilizamos a tabela do PRONAF porém a mesma metodologia pode ser aplicada para o PRONAMP

grouped = dados_bcb_pronaf.groupby('SIGLA_UF')['COMUNICACAO_PERDA_QTD_CONTRATOS'].sum()
plt.figure(figsize=(15, 8))
plt.pie(grouped, labels=grouped.index, autopct='%1.1f%%', startangle=140)
plt.axis('equal')
plt.title('Distribuição por Categoria')
plt.show()

# Carregar o shapefile dos estados do Brasil (Certifique-se de ter o arquivo "estados.shp" no diretório)
shapefile_path = "/content/BR_UF_2022.shp"
map_df = gpd.read_file(shapefile_path)

# Agrupar e calcular o investimento total por estado
df_grouped = dados_bcb_pronaf.groupby("SIGLA_UF")["ADESAO_QTDE_CONTRATOS"].sum().reset_index()

# Mesclar os dados do DataFrame com o shapefile
merged = map_df.set_index("SIGLA_UF").join(df_grouped.set_index("SIGLA_UF"))

# Plotar o mapa
fig, ax = plt.subplots(1, 1, figsize=(10, 6))
merged.plot(column="ADESAO_QTDE_CONTRATOS", cmap="YlOrRd", linewidth=0.8, ax=ax, edgecolor="0.8", legend=True)
ax.set_title("Adesão Quantidade de Contratos por Estados PRONAF")
ax.set_axis_off()
plt.show()

# Carregar o shapefile dos estados do Brasil (Certifique-se de ter o arquivo "estados.shp" no diretório)
shapefile_path = "/content/BR_UF_2022.shp"
map_df = gpd.read_file(shapefile_path)

# Agrupar e calcular o investimento total por estado
df_grouped = dados_bcb_pronaf.groupby("SIGLA_UF")["ADESAO_AREA_AMPARADA_HA"].sum().reset_index()

# Mesclar os dados do DataFrame com o shapefile
merged = map_df.set_index("SIGLA_UF").join(df_grouped.set_index("SIGLA_UF"))

# Plotar o mapa
fig, ax = plt.subplots(1, 1, figsize=(10, 6))
merged.plot(column="ADESAO_AREA_AMPARADA_HA", cmap="YlOrRd", linewidth=0.8, ax=ax, edgecolor="0.8", legend=True)
ax.set_title("Adesão Área Amparada Hectares por Estados PRONAF")
ax.set_axis_off()
plt.show()

# Carregar o shapefile dos estados do Brasil (Certifique-se de ter o arquivo "estados.shp" no diretório)
shapefile_path = "/content/BR_UF_2022.shp"
map_df = gpd.read_file(shapefile_path)

# Agrupar e calcular o investimento total por estado
df_grouped = dados_bcb_pronaf.groupby("SIGLA_UF")["ADESAO_VALOR_AMPARADO_R$"].sum().reset_index()

# Mesclar os dados do DataFrame com o shapefile
merged = map_df.set_index("SIGLA_UF").join(df_grouped.set_index("SIGLA_UF"))

# Plotar o mapa
fig, ax = plt.subplots(1, 1, figsize=(10, 6))
merged.plot(column="ADESAO_VALOR_AMPARADO_R$", cmap="YlOrRd", linewidth=0.8, ax=ax, edgecolor="0.8", legend=True)
ax.set_title("Adesão Valor Adicional por Estados PRONAF")
ax.set_axis_off()
plt.show()

# Carregar o shapefile dos estados do Brasil (Certifique-se de ter o arquivo "estados.shp" no diretório)
shapefile_path = "/content/BR_UF_2022.shp"
map_df = gpd.read_file(shapefile_path)

# Agrupar e calcular o investimento total por estado
df_grouped = dados_bcb_pronaf.groupby("SIGLA_UF")["COMUNICACAO_PERDA_AMPARADA_HA"].sum().reset_index()

# Mesclar os dados do DataFrame com o shapefile
merged = map_df.set_index("SIGLA_UF").join(df_grouped.set_index("SIGLA_UF"))

# Plotar o mapa
fig, ax = plt.subplots(1, 1, figsize=(10, 6))
merged.plot(column="COMUNICACAO_PERDA_AMPARADA_HA", cmap="YlOrRd", linewidth=0.8, ax=ax, edgecolor="0.8", legend=True)
ax.set_title("Comunicação Perdas Área Amparada por Estado PRONAF")
ax.set_axis_off()
plt.show()

# Carregar o shapefile dos estados do Brasil (Certifique-se de ter o arquivo "estados.shp" no diretório)
shapefile_path = "/content/BR_UF_2022.shp"
map_df = gpd.read_file(shapefile_path)

# Agrupar e calcular o investimento total por estado
df_grouped = dados_bcb_pronaf.groupby("SIGLA_UF")["COBERTURA_DEF_QTD_CONTRATOS"].sum().reset_index()

# Mesclar os dados do DataFrame com o shapefile
merged = map_df.set_index("SIGLA_UF").join(df_grouped.set_index("SIGLA_UF"))

# Plotar o mapa
fig, ax = plt.subplots(1, 1, figsize=(10, 6))
merged.plot(column="COBERTURA_DEF_QTD_CONTRATOS", cmap="YlOrRd", linewidth=0.8, ax=ax, edgecolor="0.8", legend=True)
ax.set_title("Comunicação Perdas Quantidade de Contratos por Estado PRONAF")
ax.set_axis_off()
plt.show()

# Carregar o shapefile dos estados do Brasil (Certifique-se de ter o arquivo "estados.shp" no diretório)
shapefile_path = "/content/BR_UF_2022.shp"
map_df = gpd.read_file(shapefile_path)

# Agrupar e calcular o investimento total por estado
df_grouped = dados_bcb_pronaf.groupby("SIGLA_UF")["COBERTURA_ANALISE_AREA_AMPARADA_HA"].sum().reset_index()

# Mesclar os dados do DataFrame com o shapefile
merged = map_df.set_index("SIGLA_UF").join(df_grouped.set_index("SIGLA_UF"))

# Plotar o mapa
fig, ax = plt.subplots(1, 1, figsize=(10, 6))
merged.plot(column="COBERTURA_ANALISE_AREA_AMPARADA_HA", cmap="YlOrRd", linewidth=0.8, ax=ax, edgecolor="0.8", legend=True)
ax.set_title("Comunicação Perdas Valor Amparado por Estado PRONAF")
ax.set_axis_off()
plt.show()

dados_concatenados = pd.concat([dados_bcb_pronaf, dados_bcb_pronaf])
dados_concatenados

dados_programas = dados_concatenados.groupby('SIGLA_UF').sum().reset_index()
dados_programas

# Carregar o shapefile dos estados do Brasil (Certifique-se de ter o arquivo "estados.shp" no diretório)
shapefile_path = "/content/BR_UF_2022.shp"
map_df = gpd.read_file(shapefile_path)

# Agrupar e calcular o investimento total por estado
df_grouped = dados_programas.groupby("SIGLA_UF")["ADESAO_AREA_AMPARADA_HA"].sum().reset_index()

# Mesclar os dados do DataFrame com o shapefile
merged = map_df.set_index("SIGLA_UF").join(df_grouped.set_index("SIGLA_UF"))

# Plotar o mapa
fig, ax = plt.subplots(1, 1, figsize=(10, 6))
merged.plot(column="ADESAO_AREA_AMPARADA_HA", cmap="YlOrRd", linewidth=0.8, ax=ax, edgecolor="0.8", legend=True)
ax.set_title("Comunicação Perdas Valor Amparado por Estado PRONAF e PRONAMP")
ax.set_axis_off()
plt.show()

# RESUMO DATAFRAME 2

# Em resumo, separamos um dataset em dois dataframes para facilitar a manipulação do mesmo, estes dataframes mostram respectivamente os dois principais programas de crédito rural do governo PRONAF e PRONAMP
# Desta forma, por meio destes dados, pode-se entender a necessidade de crédito rural por unidade federativa e analisar quais estados possuem mais ou menos carência de crédito ou até mesmo
# compreender o nível e importância dos pequenos produtores rurais dentro de um contexto nacional

dados_bcb_pronaf.dtypes

dados_bcb_pronamp

"""## Dataframes - IBGE dados de atibaia

- Adubação
"""

dados_adubacao = pd.read_csv('Adubacao.csv', sep = ';', decimal = ',', encoding = 'UTF-8')
dados_adubacao

# converter dados para int
dados_adubacao['adubacao_quimica'] = dados_adubacao['adubacao_quimica'].astype(int)
dados_adubacao['adubacao_organica'] = dados_adubacao['adubacao_organica'].astype(int)
dados_adubacao['adubacao_quimica_organica'] = dados_adubacao['adubacao_quimica_organica'].astype(int)
dados_adubacao['adubacao_nao_realizada'] = dados_adubacao['adubacao_nao_realizada'].astype(int)
dados_adubacao

# adicionar a coluna com a unidade de medida dos dados
dados_adubacao['unidade'] = 'estabelecimentos'
dados_adubacao_final = dados_adubacao
dados_adubacao_final

dados_adubacao_final.dtypes

from google.colab import files
dados_adubacao_final.to_csv('dados_adubacao_final.csv')
files.download('dados_adubacao_final.csv')

"""- Agrotóxicos"""

dados_agrotoxico = pd.read_csv('Agrotoxico.csv', sep = ';', decimal = ',', encoding = 'UTF-8')
dados_agrotoxico

dados_agrotoxico_final = dados_agrotoxico.rename(columns = {'Utilizou':'utilizado','Não utilizou':'nao_utilizado'})
dados_agrotoxico_final

# converter dados para int
dados_agrotoxico_final['utilizado'] = dados_agrotoxico_final['utilizado'].astype(int)
dados_agrotoxico_final['nao_utilizado'] = dados_agrotoxico_final['nao_utilizado'].astype(int)
dados_agrotoxico_final

# adicionar a coluna com a unidade de medida dos dados
dados_agrotoxico_final['unidade'] = 'estabelecimentos'
dados_agrotoxico_final

dados_agrotoxico_final.dtypes

from google.colab import files
dados_agrotoxico_final.to_csv('dados_agrotoxico_final.csv')
files.download('dados_agrotoxico_final.csv')

"""- Área"""

dados_area = pd.read_csv('Area.csv', sep = ';', decimal = ',', encoding = 'UTF-8')
dados_area

# renomear coluna
dados_area_final = dados_area.rename(columns = {'Área dos estabelecimentos agropecuários':'area_estabelecimentos'})
dados_area_final

# deixar somente o valor numérico na coluna para análise
dados_area_final['area_estabelecimentos'] = dados_area_final['area_estabelecimentos'].str.replace('12043 hectares', '12043')
dados_area_final

# converter dados para int
dados_area_final['area_estabelecimentos'] = dados_area_final['area_estabelecimentos'].astype(int)
dados_area_final

# adicionar a coluna com a unidade de medida dos dados
dados_area_final['unidade'] = 'hectares'
dados_area_final

dados_area_final.dtypes

from google.colab import files
dados_area_final.to_csv('dados_area_final.csv')
files.download('dados_area_final.csv')

"""- Classe Idade Produtor"""

dados_classe_idade = pd.read_csv('Classe Idade Produtores.csv', sep = ';', decimal = ',', encoding = 'UTF-8')
dados_classe_idade

# renomear colunas
dados_classe_idade_final = dados_classe_idade.rename(columns = {'Menos de 25 anos':'menor_25_anos', '25 a menos de 35 anos':'maior_25_menor_35','35 a menos de 45 anos':'maior_35_menor_45','45 a menos de 55 anos':'maior_45_menor_55','55 a menos de 65 anos':'maior_55_menor_65','65 a menos de 75 anos':'maior_65_menor_75','75 anos e mais':'maior_75_anos'})
dados_classe_idade_final

# converter dados para int
dados_classe_idade_final['menor_25_anos'] = dados_classe_idade_final['menor_25_anos'].astype(int)
dados_classe_idade_final['maior_25_menor_35'] = dados_classe_idade_final['maior_25_menor_35'].astype(int)
dados_classe_idade_final['maior_35_menor_45'] = dados_classe_idade_final['maior_35_menor_45'].astype(int)
dados_classe_idade_final['maior_45_menor_55'] = dados_classe_idade_final['maior_45_menor_55'].astype(int)
dados_classe_idade_final['maior_55_menor_65'] = dados_classe_idade_final['maior_55_menor_65'].astype(int)
dados_classe_idade_final['maior_65_menor_75'] = dados_classe_idade_final['maior_65_menor_75'].astype(int)
dados_classe_idade_final['maior_75_anos'] = dados_classe_idade_final['maior_75_anos'].astype(int)
dados_classe_idade_final

# adicionar a coluna com a unidade de medida dos dados
dados_classe_idade_final['unidade'] = 'estabelecimentos'
dados_classe_idade_final

dados_classe_idade_final.dtypes

from google.colab import files
dados_classe_idade_final.to_csv('dados_classe_idade_final.csv')
files.download('dados_classe_idade_final.csv')

"""- Condição Legal"""

dados_condicao_legal = pd.read_csv('Condicao Legal.csv', sep = ';', decimal = ',', encoding = 'UTF-8')
dados_condicao_legal

# renomear colunas
dados_condicao_legal_final = dados_condicao_legal.rename(columns = {'união':'cdm_consorcio_uniao','Produtor individual':'individual'})
dados_condicao_legal_final

# deixar somente o valor numérico na coluna para análise
dados_condicao_legal_final['cdm_consorcio_uniao'] = dados_condicao_legal_final['cdm_consorcio_uniao'].str.replace('1333 hectares', '1333')
dados_condicao_legal_final['individual'] = dados_condicao_legal_final['individual'].str.replace('10608 hectares', '10608')
dados_condicao_legal_final

# converter dados para int
dados_condicao_legal_final['cdm_consorcio_uniao'] = dados_condicao_legal_final['cdm_consorcio_uniao'].astype(int)
dados_condicao_legal_final['individual'] = dados_condicao_legal_final['individual'].astype(int)
dados_condicao_legal_final

# adicionar a coluna com a unidade de medida dos dados
dados_condicao_legal_final['unidade'] = 'hectares'
dados_condicao_legal_final

dados_condicao_legal_final.dtypes

from google.colab import files
dados_condicao_legal_final.to_csv('dados_condicao_legal_final.csv')
files.download('dados_condicao_legal_final.csv')

"""- Condicao Produtor Terra"""

dados_condicao_produtor_terra = pd.read_csv('Condicao Produtor Terra.csv', sep = ';', decimal = ',', encoding = 'UTF-8')
dados_condicao_produtor_terra

# renomear colunas
dados_condicao_produtor_terra_final = dados_condicao_produtor_terra.rename(columns = {'PROPRIETÁRIO(A) INCLUSIVE OS(AS) COPROPRIETÁRIOS(AS) DE TERRAS TITULADAS COLETIVAMENTE':'proprietarios',
                                                                                      'Arrendatário(a)':'arrendatario'})
dados_condicao_produtor_terra_final

# deixar somente o valor numérico na coluna para análise
dados_condicao_produtor_terra_final['proprietarios'] = dados_condicao_produtor_terra_final['proprietarios'].str.replace('9625 hectares', '9625')
dados_condicao_produtor_terra_final['arrendatario'] = dados_condicao_produtor_terra_final['arrendatario'].str.replace('1619 hectares', '1619')
dados_condicao_produtor_terra_final

# converter dados para int
dados_condicao_produtor_terra_final['proprietarios'] = dados_condicao_produtor_terra_final['proprietarios'].astype(int)
dados_condicao_produtor_terra_final['arrendatario'] = dados_condicao_produtor_terra_final['arrendatario'].astype(int)
dados_condicao_produtor_terra_final

# adicionar a coluna com a unidade de medida dos dados
dados_condicao_produtor_terra_final['unidade'] = 'hectares'
dados_condicao_produtor_terra_final

dados_condicao_produtor_terra_final.dtypes

from google.colab import files
dados_condicao_produtor_terra_final.to_csv('dados_condicao_produtor_terra_final.csv')
files.download('dados_condicao_produtor_terra_final.csv')

"""- Financiamento"""

dados_financiamento = pd.read_csv('Financiamento.csv', sep = ';', decimal = ',', encoding = 'UTF-8')
dados_financiamento

# renomear colunas
dados_financiamento_final = dados_financiamento.rename(columns = {'Obteve':'obteve', 'Investimento':'investimento', 'Custeio':'custeio', 'Manutenção':'manutencao',
                                                                  'Programas governamentais de crÃ©dito': 'programas_gov_de_credito', 'Pronaf': 'pronaf',
                                                                  'Pronamp' : 'pronamp' , 'Outro programa (federal, estadual ou municipal)' : 'outro_programa',
                                                                  'Outras fontes':'outras_fontes', 'Não obteve' : 'nao_obteve' })
dados_financiamento_final

# adicionar a coluna com a unidade de medida dos dados
dados_financiamento_final['unidade'] = 'estabelecimento'
dados_financiamento_final

dados_financiamento_final.dtypes

from google.colab import files
dados_financiamento_final.to_csv('dados_financiamento_final.csv')
files.download('dados_financiamento_final.csv')

"""- Laranja"""

dados_laranja = pd.read_csv('Laranja.csv', sep = ';', decimal = ',', encoding = 'UTF-8')
dados_laranja

# renomear colunas
dados_laranja_final = dados_laranja.rename(columns = {'Nro de estabelecimentos com 50 pés ou mais':'nro_estabelecimentos','Quantidade produzida': 'quantidade_produzida(t)',
                                                      'Qtde de pés' : 'qt_de_pes(unidades)', 'Área dos estabelecimentos' : 'area_estabelecimentos(ha)',
                                                      'Área colhida' : 'area_colhida(ha)', 'Valor da produção' : 'valor_producao(R$)'})
dados_laranja_final

# transformar dados para valor correto
dados_laranja_final['valor_producao(R$)'] = dados_laranja_final['valor_producao(R$)'].str.replace('R$ 112.200,00', '112.200.000', regex=False)
dados_laranja_final.loc[0, 'qt_de_pes(unidades)'] = 6000

# transformar dados para valor correto
dados_laranja_final.loc[0, 'valor_producao(R$)'] = 112200000
dados_laranja_final

# converter dados para float
dados_laranja_final['quantidade_produzida(t)'] = dados_laranja_final['quantidade_produzida(t)'].astype(float)
dados_laranja_final['valor_producao(R$)'] = dados_laranja_final['valor_producao(R$)'].astype(float)
dados_laranja_final

dados_laranja_final.dtypes

from google.colab import files
dados_laranja_final.to_csv('dados_laranja_final.csv')
files.download('dados_laranja_final.csv')

"""- Pêssego"""

dados_pessego = pd.read_csv('Pessego.csv', sep = ';', decimal = ',', encoding = 'UTF-8')
dados_pessego

# renomear colunas
dados_pessego_final = dados_pessego.rename(columns = {'Nro de estabelecimentos com 50 pés ou mais':'nro_estabelecimentos','Quantidade produzida': 'quantidade_produzida(t)',
                                                      'Qtde de pés' : 'qt_de_pes(unidades)', 'Área dos estabelecimentos' : 'area_estabelecimentos(ha)',
                                                      'Área colhida' : 'area_colhida(ha)', 'Valor da produção' : 'valor_producao(R$)' })
dados_pessego_final

# transformar dados para valor correto
dados_pessego_final.loc[0, 'qt_de_pes(unidades)'] = 53000
dados_pessego_final

dados_pessego_final['valor_producao(R$)'] = dados_pessego_final['valor_producao(R$)'].str.replace('R$ 2.621.780,00', '2.621.780.000', regex=False)
dados_pessego_final

dados_pessego_final.loc[0, 'valor_producao(R$)'] = 2621780000
dados_pessego_final

# converter dados para float
dados_pessego_final['valor_producao(R$)'] = dados_pessego_final['valor_producao(R$)'].astype(float)
dados_pessego_final['quantidade_produzida(t)'] = dados_pessego_final['quantidade_produzida(t)'].astype(float)
dados_pessego_final

dados_pessego_final.dtypes

from google.colab import files
dados_pessego_final.to_csv('dados_pessego_final.csv')
files.download('dados_pessego_final.csv')

"""- Matas Florestas"""

dados_matas = pd.read_csv('Matas Florestas.csv', sep = ';', decimal = ',', encoding = 'UTF-8')
dados_matas

# renomear colunas
dados_matas_final = dados_matas.rename(columns={'Naturais': 'naturais',
                                                'Naturais destinadas á  preservação permanente ou reserva legal': 'naturais_preservacao_reserva',
                                                'Florestas plantadas': 'florestas_plantadas'})
dados_matas_final

# renomear colunas
dados_matas_final.columns = ['naturais',
       'naturais_preservação_ou_reserva',
       'florestas_plantadas']
dados_matas_final

# transformar os dados para numéricos apenas
dados_matas_final['naturais'] = dados_matas_final['naturais'].str.replace('196 há', '196')
dados_matas_final['naturais_preservação_ou_reserva'] = dados_matas_final['naturais_preservação_ou_reserva'].str.replace('2216 ha', '2216')
dados_matas_final['florestas_plantadas'] = dados_matas_final['florestas_plantadas'].str.replace('410 ha', '410')
dados_matas_final

# adicionar a coluna com a unidade de medida dos dados
dados_matas_final['unidade'] = 'hectares'
dados_matas_final

# converter dados para int
dados_matas_final['naturais'] = dados_matas_final['naturais'].astype(int)
dados_matas_final['naturais_preservação_ou_reserva'] = dados_matas_final['naturais_preservação_ou_reserva'].astype(int)
dados_matas_final['florestas_plantadas'] = dados_matas_final['florestas_plantadas'].astype(int)
dados_matas_final

from google.colab import files
dados_matas_final.to_csv('dados_matas_final.csv')
files.download('dados_matas_final.csv')

"""Sexo"""

dados_sexo = pd.read_csv('Sexo.csv', sep = ';', decimal = ',', encoding = 'UTF-8')
dados_sexo

dados_sexo.dtypes

from google.colab import files
dados_sexo.to_csv('dados_sexo.csv')
files.download('dados_sexo.csv')
